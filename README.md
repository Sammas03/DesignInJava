# 设计模式

## 设计模式七大原则

### 1.开闭原则（open close）

* 对扩展开放，对修改关闭
  * 编写软件比如类、模块、方法

* 使用抽象进行构建，使用实现扩展细节
* 面向抽象编程
* 提高软件系统可复用

Human接口 -> Student类(implement Human) -> HighSchoolStudent类(extends Student)

### 2.依赖倒转原则（dependency Inversion）

* 是开闭原则的基础，针对接口进行编程
* 依赖抽象，而不是具体实现
* 可以减少类与类之间耦合性，提高系统稳定性，提高代码可读性
* 降低修改程序造成的风险

Human接口 -> Programmer抽象类（implement Human）

JavaProgrammer类 （extends Programmer）

TestProgrammer类（extends Programmer）



###  3.单一原则（Single responsibility）

* 一个类、接口、方法只负责一项职责

* 降低程序的复杂度，提高可维护性，降低变更所带来的风险

  

### 4.接口隔离原则（Interface Segregation）

* 用多个接口，而不是单一接口
* 尽量细化接口，接口中的方法尽量少
* 提高扩展性，符合低耦合的设计思想

### 5.迪米特原则（Demeter）

* 一个对象应该对其他对象保持最少的了解

* 强调只和成员变量或方法中输入或输出的参数进行交流

### 6.里氏替换原则（liskovsub situation）

* 是继承复用的基石，对开闭原则的补充
* 子类可以扩展父类的功能，但是不能修改父类原有的功能
* 子类可以实现父类的抽象方法，但是不能覆盖原有父类的方法
* 子类可以增加自己持有的方法
* 增加程序的健壮性

### 7.合成复用原则（Composition aggregation)

* 尽量使用组合、聚合的方式，而不是使用继承关系达到软件复用的目的
* 可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响较小



## 设计模式

* 创建型模式：
  * 隐藏了创界对象的过程，通过逻辑方法进行创建对象，而不是new
    * 工厂方法模式（factorymethod）：对于相同系列的类
      * 定义一个接口或者一个抽象的工厂类，让它实现类（工厂）来决定创建哪一个实例对象
      * 根据每个工厂的不同方法，来产生不同的所需要的对象
      
    * 抽象工厂模式（abstractfactory）：对于不相同系列的类
      * 类似公司下的产品，进行生产。
      * 例如生产汽车，将汽车分为各个零部件生产，但都是在公司内生产的不同产品。
      * 提供了一个创建一系列相关或互相依赖对象的接口
      
    * 单例模式
    
      * 懒汉式（lazy）
      * 双重检查（doublecheck）
      * 饿汉式（hungry）
      * 静态内部类(staticInnerClass)
      * 枚举（enum）
        * 最佳的实现方式，有效防止对单例模式破坏
          * 序列化和反序列化的方式破坏单例模式
          * 通过反射的方式破坏单例模式
    
      
    
    * 建造者模式（builder）
      * 将复杂的对象的创建和属性赋值所分离
      * 建造的过程和细节我们不需要知道
      
    * 原型模式（prototype）
      * 用于创建重复的对象
      * 原型设计模式是创建对象的最佳方式
  
* 结构型模式：
  * 主要关注类和对象的组合关系
  * 继承的概念被用来组合接口和定义组合对象，获得新的功能方式
    * 外观模式(faced)
      * 提供了一个统一的接口，用来访问子系统中一群接口
      * 定义了一个高层接口，让子系统使用更加容易
    * 适配器模式（adapter）
      * 是作为两个不兼容的接口之间的桥梁，将一个类的接口转换成另一个接口
      * 适配器模式使得原本由于接口不兼容不能一起工作的类可以一起工作
      * 结合了两个独立接口的功能
    * 桥接模式（bridge）连接接口和抽象类
      * 用于把抽象化与实现化解耦，使得二者可以独立变化
      * 使用一个作为桥接的接口，使得实体类的功能独立于接口的实现类，这两种类型的类可被结构化改变而互不影响
    * 组合模式（composition）
      * 又叫部分整体模式，把一组类似的对象当作单一的对象
      * 依据树形结构来组合对象，创建了对象组的树形结构
      * 提供了修改对象组的方式
    * 装饰模式（decoration）
      * 在原有对象不做改变的基础上，将对象的功能附加上
      * 扩展原有对象功能
    * 享元模式（flyweight）
      * 提供了减少对象数量从而改善应用所需的对象结构的方式
      * 运用共享技术有效的支持大量细粒度的对象
      * 减少创建
    * 代理模式（proxy）
      * 为对象提供一种代理，控制对象的访问
      * 代理对象和目标对象之间起到中介作用
      * 保护目标对象和增强目标对象
      * 降低耦合度
  
* 行为型模式：
  * 主要关注对象之间的通信
    * 模版方法模式
      * 定义一个算法的架构，允许子类为一个或多个步骤的实现
      * 在不改变算法结构的情况下，重新定义算法的某些步骤
      * 实现一个算法的不变的部分，并将可变的空间留给子类完成
      * 子类中公共的行为抽取出来并封装到一个公共父类中，避免代码重复

除了以上23种外：简单工厂模式（simple factory），由哪一个工厂决定创建哪一种产品的实例

​					
